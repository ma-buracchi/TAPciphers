\chapter{Testing}

	\section{Unit testing}
		Per tutti i test viene supposto che le stringhe da cifrare siano state processate dal parser e quindi che contengano solamente caratteri effettivamente cifrabili. Per eliminare tale dipendenza da classi concrete, nei vari unit-test un'istanza del parser viene simulata tramite \emph{mocking} e \emph{stubbing} dei metodi. Tale metodo verrà approfondito più avanti.
		
		Andiamo a vedere nel dettaglio i test con i quali sono state implementate le varie classi.
		
		\subsection{Shift cipher}
			Lo \emph{shift cipher} è il cifrario più semplice. L'unica cosa che fa è spostare la lettere da cifrare di un certo numero di posizioni avanti nell'alfabeto. Tale numero di posizioni è la chiave del cifrario. Per decifrare il messaggio basterà semplicemente tornare indietro del numero di posizioni indicato dalla chiave. Se per esempio il messaggio è \emph{ciao} e la chiave è 3, il messaggio cifrato sarà \emph{fldr}.
			
			Le uniche due funzionalità richieste a questo cifrario sono quelle di cifratura e decifratura. Tali funzionalità sono state testate nel caso di uno spostamento di zero posizioni (non ottenendo una cifratura), di una posizione, di ventisei posizioni, di ventisette posizioni e di un numero negativo di posizioni(-1). Come caso limite è stata testata anche la cifratura della stringa vuota (il numero di posizioni è ininfluente dato che la cifratura terminerà immediatamente).
			
			Testando anche la decifratura di tutti questi casi sono state coperte le possibili modalità di cifratura/decifratura di una stringa.
			
		\subsection{Affine cipher}
			L'Affine cipher è una generalizzazione dello shift cipher. Questo cifrario ha come chiave due parametri \emph{a} e \emph{b} opportunamente scelti secondo principi di algebra modulare. La i-esima lettera P[i] del messaggio in chiaro verrà cifrata in (P[i] * \emph{a} + \emph{b}) modulo 26. Se viene scelto il parametro \emph{a} = 1 otteniamo in tutto e per tutto uno shift cipher.
			
			I comportamenti da testare sono la cifratura, la decifratura e la giusta scelta del  parametro \emph{a} che deve essere coprimo con 26.
			
			Questo ultimo comportamento viene testato dando in input 2 come coefficiente \emph{a} e aspettandosi una IllegalArgumentException.
			
			La cifratura e la decifratura vengono testate con stringhe di lunghezza zero, uno e quattro (quest'ultima scelta è dovuta esclusivamente al fatto di voler cifrare una stringa con un senso compiuto che in questo caso è \emph{test})
			
		\subsection{Vigenere cipher}
			Il \emph{cifrario di Vigenère} è un'altra variante dello shift cipher che invece di utilizzare come chiave un numero fisso, utilizza una parola che viene ripetuta tante volte fino al raggiungimento della lunghezza del messaggio che si vuole cifrare. Ogni lettera verrà poi traslata del numero di posizioni corrispondenti alla posizione nell'alfabeto della corrispondente lettera della chiave.
			
			Se per esempio abbiamo un certo messaggio P da cifrare con una chiave K, allora come prima cosa verrà ripetuta K tante volte fino a che la sua lunghezza non raggiunge quella di P e poi ogni i-esima lettera P[i] del messaggio sarà cifrata in P[i]+K[i] modulo 26.
			
			Cifrare il messaggio \emph{testmessage} con la chiave \emph{test} comporterà tre ripetizioni della chiave (che quindi diventerà \emph{testtesttest}). Conseguentemente la prima lettera del messaggio (\emph{t}) verrà spostata di venti posizioni (verrà cifrata con la prima lettera della chiave che è \emph{t} ed è la ventesima lettera dell'alfabeto), la seconda di cinque e così via.
			
			I comportamenti da testare sono la cifratura, la decifratura e il prolungamento della chiave.
			
			Cifratura e decifratura sono testati con stringhe di lunghezza zero, uno e undici caratteri (come sopra, quest'ultima scelta è dovuta esclusivamente al fatto di voler cifrare una stringa con un senso compiuto che in questo caso è \emph{testmessage}).
			
			L'estensione della chiave viene testata fornendo la stringa \emph{test} come chiave, facendo cifrare il messaggio \emph{testmessage} e verificando che sia stata trasformata in \emph{testtesttest}.
			
			Sono presenti anche tre test che controllano l'inserimento di una chiave illegale. Questi test sono stati inseriti per chiarire meglio il comportamento di questa classe ma sarebbero inutili in quanto questo controllo viene in realtà fatto dal parser.
			
		\subsection{Substitution cipher}
			Anche il substitution cipher è un cifrario abbastanza semplice che utilizza come chiave di cifratura una permutazione dell'alfabeto. Se per esempio la permutazione utilizzata è \emph{qwertyuiopasdfghjklzxcvbnm} la lettera \emph{a} verrà sostituita con la \emph{q}, la \emph{b} con la \emph{w} e così via fino a scambiare la \emph{z} con la \emph{m}.
			
			I comportamenti importanti da testare per questo cifrario sono ovviamente la cifratura e la decifratura ma anche il corretto settaggio della permutazione dell'alfabeto da utilizzare come chiave.
			
			Cifratura e decifratura vengono testate con stringhe lunghe zero (stringa vuota), uno e quattro caratteri (questa scelta è dovuta solamente per cercare la cifratura di una stringa di senso compiuto, in questo caso \emph{test}). La permutazione utilizzata è appunto quella specificata nell'esempio iniziale.
			
			Come prima, i test riguardanti il controllo della permutazione di cifratura in realtà non sarebbero necessari in quanto già presenti nei test del parser (che è quello che si occupa di questo controllo) ma sono stati aggiunti per specificare meglio il comportamento che deve avere la classe in caso di inserimento di una permutazione scorretta (troppo corta, troppo lunga o con caratteri non alfabetici).
			
		\subsection{Mocking}
	\section{Mutation testing}
	\section{Integration testing}
	\section{Test sull'interfaccia}